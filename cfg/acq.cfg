// config file for beacon-acq
// not all options are changeable by restart

// settings related to threshold  / trigger control
// These all can be set without restarting
control:
{
   // scaler goals for each beam, desired rate ( in Hz)
   scaler_goal = {
     beam0  : 0.75;
     beam1  : 0.75;
     beam2  : 0.75;
     beam3  : 0.75;
     beam4  : 0.75;
     beam5  : 0.75;
     beam6  : 0.75;
     beam7  : 0.75;
     beam8  : 0.75;
     beam9  : 0.75;
     beam10 : 0.75;
     beam11 : 0.75;
     beam12 : 0.75;
     beam13 : 0.75;
     beam14 : 0.75;
     beam15 : 0.75;
     beam16 : 0.75;
     beam17 : 0.75;
     beam18 : 0.75;
     beam19 : 0.75;
     beam20 : 0.0;
     beam21 : 0.0;
     beam22 : 0.0;
     beam23 : 0.0;
    };

    // fixed thresholds for each beam (in case of use_fixed_thresholds) 
    fixed_threshold = { 
     beam0  : 30000;
     beam1  : 30000;
     beam2  : 30000;
     beam3  : 30000;
     beam4  : 30000;
     beam5  : 30000;
     beam6  : 30000;
     beam7  : 30000;
     beam8  : 30000;
     beam9  : 30000;
     beam10 : 30000;
     beam11 : 30000;
     beam12 : 30000;
     beam13 : 30000;
     beam14 : 30000;
     beam15 : 30000;
     beam16 : 30000;
     beam17 : 30000;
     beam18 : 30000;
     beam19 : 30000;
     beam20 : 0;
     beam21 : 0;
     beam22 : 0; 
     beam23 : 0; 
    }


   //the beams allowed to participate in the trigger
   trigger_mask = 0xffffff;

   // the channels on the master allowed to participate in the trigger
   channel_mask = 0xff;

   // enable on-board dynamic masking
   enable_dynamic_masking = 1; 

   // dynamic_masking_threshold
   dynamic_masking_threshold = 1; 

   // dynamic_masking_holdoff
   dynamic_masking_holdoff = 1000; 

   // use fixed thresholds (don't servo!) 
   use_fixed_thresholds = 1; 
   
   // pid loop proportional term
   k_p = 10;

   // pid loop integral term
   k_i = 0.1;

   // pid loop differential term
   k_d = 0;

   // puts a floor on the thresholds
   min_threshold=1000;

   // max threshold increase per step 
   max_threshold_increase=1000;

   //monitoring interval, for PID loop (in seconds)
   monitor_interval = 1;

   // software trigger interval (in seconds)
   sw_trigger_interval = 0.2;

   // randomize sw trigger interval (using exponential distribution) 
   randomize_sw_trigger = 0; 

   //enable the phased trigger readout
   enable_phased_trigger = 0;

   // Polarization for triggering, current options are "H", "V"
   // @see config_lookup_pol in beacon-cfg.c
   // @see beacon_trigger_polarization_t in beacondaq.h in libbeacon
   trigger_polarization = "H";

   //delay for phased trigger to start
   secs_before_phased_trigger = 20;

   //weight of fast scaler in pid loop
   fast_scaler_weight = 0.7;

   //weight of slow scaler in pid loop
   slow_scaler_weight = 0.3;

   //number of fast scalers to average
   n_fast_scaler_avg = 20;

   //Whether or not to subtract off gated scalers
   subtract_gated = 1;

   //File to persist the status info (primarily for saving thresholds between restarts)
   status_save_file = "/beacon/last.st.bin"

   // load thresholds from status file on start.
   load_thresholds_from_status_file=1

};

// settings related to the acquisition
// Not all of these can be set without restarting
device: 
{
  //spi devices, master first, requires restart to change
  spi_device = "/dev/spidev1.0"; 

  // circular buffer capacity. In-memory storage in between acquisition and writing. Requires restart.
  buffer_capacity = 256;

  //the length of a waveform, in samples. 
  waveform_length = 2048;

  //the pretrigger window length, in hardware units
  pretrigger = 6;

  //calpulser state, 0 (off) , 2 (baseline)  or 3 (calpulser)
  calpulser_state = 0;

  // Whether or not to enable the trigger output
  enable_trigout = 1;

  // Whether or not to enable external trigger input
  enable_extin = 0;

  // The width of the trigger output in 40 ns intervals
  trigout_width = 3;

  // Whether or not to disable the trigger output on exit
  disable_trigout_on_exit = 1;

  //spi clock speed, MHz
  spi_clock = 20;

  // True to apply attenuations 
  apply_attenuations = 0;

  // attenuation, per channel, if applied. 
  attenuation =  {ch0: 9;  ch1: 3;  ch2: 11;  ch3: 8;  ch4: 7;  ch5: 19;  ch6: 11;  ch7: 3;  } ;

  //which channels to digitize
  channel_read_mask = 0xff; 

  //command used to run the alignment program.

  alignment_command="cd /home/nuphase/nuphase_python/;  python align_adcs_beacon.py",

  //channel trig delays (right now can be 0-3)
  trig_delays = {
     ch0 : 0;
     ch1 : 0;
     ch2 : 0;
     ch3 : 0;
     ch4 : 0;
     ch5 : 0;
     ch6 : 0;
     ch7 : 0;
  };

  // Enable the low pass to trigger
  enable_low_pass_to_trigger = 0; 



};

//settings related to output
output: 
{
  // Run file, used to persist run number
  run_file = "/beacon/runfile";

  // output directory, data will go here
  output_directory = "/data/" ;

  //print to screen interval (0 to disable)
  print_interval = 10;

  // run length, in seconds
  run_length = 10800; 

  //events per output file
  events_per_file = 1000;

  //statuses per output file
  status_per_file = 200;

  //realtime priority setting. If 0, will use non-realtime priority. Otherwise, SCHED_FIFO is used with the given priority
  realtime_priority = 20;

  //Interval between polling SPI link for data. 0 to just sched_yield
  poll_usecs = 500;

  // Colon separated list of paths to copy (recursively) into run dir at start of run
  copy_paths_to_rundir = "/home/nuphase/nuphase_python/output:/proc/loadavg";

  //Whether or not to copy configs into run dir
  copy_configs = 1;
};

